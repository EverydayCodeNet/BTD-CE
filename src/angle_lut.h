#ifndef ANGLE_LUT_H
#define ANGLE_LUT_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>

/*
 * 256-entry cos/sin lookup table.
 * Angle 0..255 maps to 0..360 degrees.
 * Values are fixed-point x256 (so cos(0) = 256, sin(64) = 256).
 *
 * To use: dx = (cos_lut[angle] * speed) >> 8
 *         dy = (sin_lut[angle] * speed) >> 8
 */

static const int16_t cos_lut[256] = {
     256,  256,  256,  255,  255,  254,  253,  252,
     251,  250,  248,  247,  245,  243,  241,  238,
     236,  233,  230,  227,  224,  220,  217,  213,
     209,  205,  201,  197,  192,  188,  183,  178,
     173,  168,  163,  158,  152,  147,  141,  136,
     130,  124,  118,  112,  106,  100,   94,   88,
      82,   76,   69,   63,   57,   50,   44,   38,
      31,   25,   19,   12,    6,    0,   -6,  -12,
     -19,  -25,  -31,  -38,  -44,  -50,  -57,  -63,
     -69,  -76,  -82,  -88,  -94, -100, -106, -112,
    -118, -124, -130, -136, -141, -147, -152, -158,
    -163, -168, -173, -178, -183, -188, -192, -197,
    -201, -205, -209, -213, -217, -220, -224, -227,
    -230, -233, -236, -238, -241, -243, -245, -247,
    -248, -250, -251, -252, -253, -254, -255, -255,
    -256, -256, -256, -256, -256, -256, -256, -256,
    -256, -256, -256, -255, -255, -254, -253, -252,
    -251, -250, -248, -247, -245, -243, -241, -238,
    -236, -233, -230, -227, -224, -220, -217, -213,
    -209, -205, -201, -197, -192, -188, -183, -178,
    -173, -168, -163, -158, -152, -147, -141, -136,
    -130, -124, -118, -112, -106, -100,  -94,  -88,
     -82,  -76,  -69,  -63,  -57,  -50,  -44,  -38,
     -31,  -25,  -19,  -12,   -6,    0,    6,   12,
      19,   25,   31,   38,   44,   50,   57,   63,
      69,   76,   82,   88,   94,  100,  106,  112,
     118,  124,  130,  136,  141,  147,  152,  158,
     163,  168,  173,  178,  183,  188,  192,  197,
     201,  205,  209,  213,  217,  220,  224,  227,
     230,  233,  236,  238,  241,  243,  245,  247,
     248,  250,  251,  252,  253,  254,  255,  255,
     256,  256,  256,  256,  256,  256,  256,  256,
};

static const int16_t sin_lut[256] = {
       0,    6,   12,   19,   25,   31,   38,   44,
      50,   57,   63,   69,   76,   82,   88,   94,
     100,  106,  112,  118,  124,  130,  136,  141,
     147,  152,  158,  163,  168,  173,  178,  183,
     188,  192,  197,  201,  205,  209,  213,  217,
     220,  224,  227,  230,  233,  236,  238,  241,
     243,  245,  247,  248,  250,  251,  252,  253,
     254,  255,  255,  256,  256,  256,  256,  256,
     256,  256,  256,  256,  256,  256,  255,  255,
     254,  253,  252,  251,  250,  248,  247,  245,
     243,  241,  238,  236,  233,  230,  227,  224,
     220,  217,  213,  209,  205,  201,  197,  192,
     188,  183,  178,  173,  168,  163,  158,  152,
     147,  141,  136,  130,  124,  118,  112,  106,
     100,   94,   88,   82,   76,   69,   63,   57,
      50,   44,   38,   31,   25,   19,   12,    6,
       0,   -6,  -12,  -19,  -25,  -31,  -38,  -44,
     -50,  -57,  -63,  -69,  -76,  -82,  -88,  -94,
    -100, -106, -112, -118, -124, -130, -136, -141,
    -147, -152, -158, -163, -168, -173, -178, -183,
    -188, -192, -197, -201, -205, -209, -213, -217,
    -220, -224, -227, -230, -233, -236, -238, -241,
    -243, -245, -247, -248, -250, -251, -252, -253,
    -254, -255, -255, -256, -256, -256, -256, -256,
    -256, -256, -256, -256, -256, -256, -255, -255,
    -254, -253, -252, -251, -250, -248, -247, -245,
    -243, -241, -238, -236, -233, -230, -227, -224,
    -220, -217, -213, -209, -205, -201, -197, -192,
    -188, -183, -178, -173, -168, -163, -158, -152,
    -147, -141, -136, -130, -124, -118, -112, -106,
    -100,  -94,  -88,  -82,  -76,  -69,  -63,  -57,
     -50,  -44,  -38,  -31,  -25,  -19,  -12,   -6,
};

/*
 * Integer atan2 returning 0..255 (0 = right, 64 = down, 128 = left, 192 = up).
 * Uses octant-based approximation. No floats.
 */
static inline uint8_t iatan2(int16_t dy, int16_t dx) {
    uint8_t angle;
    int16_t ax = dx < 0 ? -dx : dx;
    int16_t ay = dy < 0 ? -dy : dy;

    /* Approximate atan(ay/ax) scaled to 0..31 for one octant */
    if (ax == 0 && ay == 0) return 0;

    uint8_t oct_angle;
    if (ax >= ay) {
        /* 0..31 via linear approx: 32*ay / (ax + ay/4) clamped */
        int32_t num = (int32_t)ay * 32;
        int32_t den = (int32_t)ax + ((int32_t)ay >> 2);
        if (den == 0) den = 1;
        oct_angle = (uint8_t)(num / den);
        if (oct_angle > 31) oct_angle = 31;
    } else {
        int32_t num = (int32_t)ax * 32;
        int32_t den = (int32_t)ay + ((int32_t)ax >> 2);
        if (den == 0) den = 1;
        oct_angle = (uint8_t)(num / den);
        if (oct_angle > 31) oct_angle = 31;
        oct_angle = 64 - oct_angle;
    }

    /* Map to correct quadrant */
    if (dx >= 0 && dy >= 0)      angle = oct_angle;         /* Q1: 0..63 */
    else if (dx < 0 && dy >= 0)  angle = 128 - oct_angle;   /* Q2: 64..128 */
    else if (dx < 0 && dy < 0)   angle = 128 + oct_angle;   /* Q3: 128..192 */
    else                          angle = 256 - oct_angle;   /* Q4: 192..255 */

    return angle;
}

#ifdef __cplusplus
}
#endif

#endif
